import React, { Component } from 'react';
import pick from 'lodash/pick';
import flatten from 'lodash/flatten';
import set from 'lodash/set';
import get from 'lodash/get';

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal;

var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
var root = _freeGlobal || freeSelf || Function('return this')();
var _root = root;

var Symbol$1 = _root.Symbol;
var _Symbol = Symbol$1;

var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];
  try {
    value[symToStringTag] = undefined;
  } catch (e) {}
  var result = nativeObjectToString.call(value);
  {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var _getRawTag = getRawTag;

var objectProto$1 = Object.prototype;
var nativeObjectToString$1 = objectProto$1.toString;
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}
var _objectToString = objectToString;

var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag$1 && symToStringTag$1 in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}
var _baseGetTag = baseGetTag;

function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}
var isObject_1 = isObject;

var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';
function isFunction(value) {
  if (!isObject_1(value)) {
    return false;
  }
  var tag = _baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
var ReactIs = require('react-is');
var allowedProps = ['dangerouslySetInnerHTML', 'target', 'height', 'width', 'id', 'src', 'children', 'type', 'className', 'style', 'href', 'alt', 'htmlFor'];
var i = 0;
var serializeChild = function serializeChild(child) {
  if (Array.isArray(child)) {
    return serializeChildren(child);
  } else if ((ReactIs.isContextConsumer(child) || ReactIs.isContextProvider(child)) && child.props && child.props.children) {
    if (isFunction_1(child.props.children)) {
      return serializeElement(child.props.children(child.type._currentValue));
    } else {
      return serializeChildren(child.props.children);
    }
  } else if (child != null && !Array.isArray(child) && React.isValidElement(child)) {
    return serializeElement(child);
  } else {
    return child;
  }
};
var serializeChildren = function serializeChildren(children) {
  if (children != null) {
    children = !Array.isArray(children) ? [children] : children;
    return flatten(children.filter(function (child) {
      return child != null;
    })).map(serializeChild);
  }
  return children;
};
var serializeElement = function serializeElement(element) {
  var el = element;
  while (el !== null && isFunction_1(el.type)) {
    if (ReactIs.isPortal(el)) {
      el = null;
      break;
    }
    var newEl = new el.type(el.props);
    if (newEl.render != null) {
      el = newEl.render();
    } else {
      el = newEl;
    }
  }
  if (ReactIs.isPortal(el)) {
    el = null;
  }
  if (el == null || el.props == null) {
    return el;
  }
  var _el = el,
      _el$props = _el.props,
      children = _el$props.children,
      restProps = _objectWithoutProperties(_el$props, ['children']),
      type = _el.type,
      key = _el.key;
  return {
    type: type,
    props: _extends({}, pick(restProps, allowedProps), {
      children: serializeChildren(children)
    })
  };
};
var renderChild = function renderChild(child, renderChange) {
  if (child != null && child.diffType != null) {
    var diffType = child.diffType,
        children = _objectWithoutProperties(child, ['diffType']);
    return React.createElement(renderChange, {
      type: diffType,
      children: renderChild(children, renderChange),
      key: 'key-child-' + i++
    });
  } else if (child != null && child.props != null) {
    return renderElement(child, renderChange);
  } else if (Array.isArray(child)) {
    return renderChildren(child, renderChange);
  } else {
    return child;
  }
};
var renderChildren = function renderChildren(children, renderChange) {
  if (Array.isArray(children)) {
    return children.filter(function (child) {
      return child != null;
    }).map(function (child, index) {
      if (child != null && child.props != null) {
        return _extends({}, child, {
          props: _extends({}, pick(child.props, allowedProps), {
            key: 'key-fix-' + index
          })
        });
      }
      return child;
    }).map(function (val) {
      return renderChild(val, renderChange);
    });
  } else {
    return renderChild(children, renderChange);
  }
};
var renderElement = function renderElement(serializedElement, renderChange) {
  var type = serializedElement.type,
      _serializedElement$pr = serializedElement.props,
      children = _serializedElement$pr.children,
      restProps = _objectWithoutProperties(_serializedElement$pr, ['children']);
  var newProps = _extends({
    key: 'key-fix-' + i++
  }, restProps);
  if (children != null) {
    newProps.children = renderChildren(children, renderChange);
  }
  return React.createElement(type, newProps);
};

var Flatted = (function (Primitive, primitive) {
  var Flatted = {
    parse: function parse(text, reviver) {
      var input = JSON.parse(text, Primitives).map(primitives);
      var value = input[0];
      var $ = reviver || noop;
      return $(
        '',
        typeof value === 'object' && value ?
          revive(input, new Set, value, $) :
          value
      );
    },
    stringify: function stringify(value, replacer, space) {
      for (var
        firstRun,
        known = new Map,
        input = [],
        output = [],
        $ = replacer && typeof replacer === typeof input ?
              function (k, v) {
                if (k === '' || -1 < replacer.indexOf(k)) return v;
              } :
              (replacer || noop),
        i = +set$$1(known, input, $('', value)),
        replace = function (key, value) {
          if (firstRun) {
            firstRun = !firstRun;
            return i < 1 ? value : $(key, value);
          }
          var after = $(key, value);
          switch (typeof after) {
            case 'object':
              if (after === null) return after;
            case primitive:
              return known.get(after) || set$$1(known, input, after);
          }
          return after;
        };
        i < input.length; i++
      ) {
        firstRun = true;
        output[i] = JSON.stringify(input[i], replace, space);
      }
      return '[' + output.join(',') + ']';
    }
  };
  return Flatted;
  function noop(key, value) {
    return value;
  }
  function revive(input, parsed, output, $) {
    return Object.keys(output).reduce(
      function (output, key) {
        var value = output[key];
        if (value instanceof Primitive) {
          var tmp = input[value];
          if (typeof tmp === 'object' && !parsed.has(tmp)) {
            parsed.add(tmp);
            output[key] = $(key, revive(input, parsed, tmp, $));
          } else {
            output[key] = $(key, tmp);
          }
        } else
          output[key] = $(key, value);
        return output;
      },
      output
    );
  }
  function set$$1(known, input, value) {
    var index = Primitive(input.push(value) - 1);
    known.set(value, index);
    return index;
  }
  function primitives(value) {
    return value instanceof Primitive ? Primitive(value) : value;
  }
  function Primitives(key, value) {
    return typeof value === primitive ? new Primitive(value) : value;
  }
}(String, 'string'));
var cjs = Flatted;

var _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
var isString$1 = function isString(obj) {
  return typeof obj === 'string';
};
var stringify = function stringify(obj) {
  return cjs.stringify(obj);
};
var toType = function toType(obj) {
  return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
};
var diffChildren = function diffChildren(left, right, changes, leftPath, rightPath) {
  if (![left, right].every(Array.isArray)) {
    return diff(left, right, changes, leftPath, rightPath);
  }
  var leftSide = left.map(stringify);
  var rightSide = right.map(stringify);
  var leftChanges = [];
  var rightChanges = [];
  leftSide.forEach(function (item, index) {
    if (!rightSide.includes(item)) {
      leftChanges.push(index);
    }
  });
  rightSide.forEach(function (item, index) {
    if (!leftSide.includes(item)) {
      rightChanges.push(index);
    }
  });
  var lengthDifference = rightChanges.length - leftChanges.length;
  if (lengthDifference < 0) {
    rightChanges = rightChanges.concat(Array(Math.abs(lengthDifference)).fill(null));
  }
  rightChanges.forEach(function (_, index) {
    diff(left[leftChanges[index]], right[rightChanges[index]], changes, leftPath.concat([leftChanges[index]]), rightPath.concat([rightChanges[index]]));
  });
  return changes;
};
var diffProps = ['className', 'src', 'style'];
var makeElementString = function makeElementString(element) {
  return Array.isArray(element) ? stringify(element) : stringify({
    type: element.type,
    props: _extends$1({}, pick(element.props, diffProps), {
      children: toType(element.props.children)
    })
  });
};
var diff = function diff(left, right) {
  var changes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  var leftPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var rightPath = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  var newLeftPath = rightPath.slice(0, -1).concat(leftPath.slice(-1));
  if ([left, right].every(Array.isArray)) {
    diffChildren(left, right, changes, leftPath, rightPath);
  } else if (isObject_1(left) && isObject_1(right)) {
    var leftString = makeElementString(left);
    var rightString = makeElementString(right);
    if (leftString !== rightString) {
      if (left) changes.push({
        path: newLeftPath,
        diffType: 'removed',
        value: left
      });
      if (right) changes.push({
        path: rightPath,
        diffType: 'added',
        value: right
      });
    } else {
      diffChildren(left.props.children, right.props.children, changes, leftPath.concat(['props', 'children']), rightPath.concat(['props', 'children']));
    }
  } else if (left !== right) {
    if ([left, right].every(isString$1)) {
      changes.push({ path: rightPath, diffType: 'updated', left: left, right: right });
    } else {
      if (left) changes.push({ path: newLeftPath, diffType: 'removed', value: left });
      if (right) changes.push({ path: rightPath, diffType: 'added', value: right });
    }
  }
  return changes;
};

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
var _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }
var jsdiff = require('diff');
var addedBlock = { padding: '0.3em', background: 'green', color: '#fff' };
var removedBlock = { background: 'red', color: '#fff', padding: '0.3em' };
var addedInline = _extends$2({}, addedBlock, { display: 'inline-block' });
var removedInline = _extends$2({}, removedBlock, { display: 'inline-block' });
var blockElements = ['div', 'hr', 'ul', 'li', 'h1', 'h2', 'h3', 'h4', 'p'];
var renderChange = function renderChange(_ref) {
  var type = _ref.type,
      children = _ref.children;
  if (children == null) {
    return null;
  }
  if (children != null && blockElements.includes(children.type)) {
    return React.createElement(
      'div',
      {
        style: type === 'added' ? addedBlock : removedBlock
      },
      children
    );
  }
  return React.createElement(
    'span',
    {
      style: type === 'added' ? addedInline : removedInline
    },
    children
  );
};
var transformValue = function transformValue(val, diffType) {
  if (typeof val === 'string') {
    return { diffType: diffType, type: 'span', props: { children: val } };
  } else if (Array.isArray(val)) {
    return val.map(function (item) {
      return transformValue(item, diffType);
    });
  } else {
    return _extends$2({}, val, { diffType: diffType });
  }
};
var reduceChange = function reduceChange(acc, _ref2) {
  var path = _ref2.path,
      diffType = _ref2.diffType,
      value = _ref2.value,
      left = _ref2.left,
      right = _ref2.right;
  if (diffType === 'updated') {
    value = jsdiff.diffWords(left, right).map(function (item) {
      if (item.added === true) {
        return {
          type: 'span',
          diffType: 'added',
          props: {
            children: item.value
          }
        };
      } else if (item.removed == true) {
        return {
          type: 'span',
          diffType: 'removed',
          props: {
            children: item.value
          }
        };
      } else {
        return item.value;
      }
    });
    return set(acc, path, value);
  } else if (diffType === 'removed') {
    var _path$slice = path.slice(-2),
        _path$slice2 = _slicedToArray(_path$slice, 2),
        prevLast = _path$slice2[0],
        last = _path$slice2[1];
    if (prevLast === 'children') {
      var children = get(acc, path.slice(0, -1)) || [];
      return set(acc, path.slice(0, -1), flatten([].concat(_toConsumableArray(children.slice(0, last)), [transformValue(value, diffType)], _toConsumableArray(children.slice(last)))));
    }
  } else if (diffType === 'added') {
    return set(acc, path, transformValue(value, diffType));
  }
  return acc;
};
var filterNumbers = function filterNumbers(arr) {
  return arr.filter(function (item) {
    return typeof item === 'number';
  });
};
var ReactVisualDiff = function (_Component) {
  _inherits(ReactVisualDiff, _Component);
  function ReactVisualDiff() {
    _classCallCheck(this, ReactVisualDiff);
    return _possibleConstructorReturn(this, (ReactVisualDiff.__proto__ || Object.getPrototypeOf(ReactVisualDiff)).apply(this, arguments));
  }
  _createClass(ReactVisualDiff, [{
    key: 'render',
    value: function render() {
      var left = serializeElement(this.props.left);
      var right = serializeElement(this.props.right);
      var changes = diff(left, right).sort(function (changeA, changeB) {
        var pathA = filterNumbers(changeA.path);
        var pathB = filterNumbers(changeB.path);
        for (var i = 0; i < pathA.length; i++) {
          if (pathA[i] > pathB[i]) {
            return -1;
          } else if (pathA[i] < pathB[i]) {
            return 1;
          } else if (changeA.diffType === 'added') {
            return -1;
          } else if (changeB.diffType === 'added') {
            return 1;
          }
        }
        return 0;
      });
      var merged = changes.reduce(reduceChange, right);
      return renderElement(merged, this.props.renderChange);
    }
  }]);
  return ReactVisualDiff;
}(Component);
ReactVisualDiff.defaultProps = {
  renderChange: renderChange
};

export default ReactVisualDiff;
//# sourceMappingURL=index.es.js.map
